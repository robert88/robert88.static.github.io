以下个核心概念
entry
output
plugins
mode
optimization
devtool
resolve
module.rules.loader
target
externals
----------------------------
https://webpack.js.org/configuration/configuration-languages/
---------------------------
entry
来指定一个入口起点（或多个入口起点）。默认值为 "./src"
entry不配置的情况下，默认值是"./src"，webpack就会找到src目录下的index.js打包到output里面

--------------------------
devtool
https://www.cnblogs.com/wangyingblog/p/7027540.html
eval	每个module会封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL.
source-map	生成一个SourceMap文件.
hidden-source-map	和 source-map 一样，但不会在 bundle 末尾追加注释.
inline-source-map	生成一个 DataUrl 形式的 SourceMap 文件.
eval-source-map	每个module会通过eval()来执行，并且生成一个DataUrl形式的SourceMap.
cheap-source-map	生成一个没有列信息（column-mappings）的SourceMaps文件，不包含loader的 sourcemap（譬如 babel 的 sourcemap）
cheap-module-source-map	生成一个没有列信息（column-mappings）的SourceMaps文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。


webpack 不仅支持这 7 种，而且它们还是可以任意组合上面的eval、inline、hidden关键字，就如文档所说，你可以设置 souremap 选项为 cheap-module-inline-source-map。
cheap-module-eval-source-map
cheap-module-hidden-source-map
cheap-module-inline-source-map

----------------------------
mode
"development" //|| "production",
开发模式，不会混淆压缩打包，只是正常的合并
默认值为production
会混淆打包

-------------------------
默认即没有entry也没有output的情况下，webpack会进行下列操作
1、entry就会找到"./src/index.js",
mode:"production"并且混淆压缩的方式
打包到"./dist/main.js"

mode:"development" 来取消混淆打包，看看打包之后的文件是什么样的
原理利用表达式 !function(){console.log(arguments)}(1,2)的方式包裹函数
会模拟node调用的方式
****/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
最终返回return module.exports;
https://segmentfault.com/a/1190000010955254

devtool：默认是eval
会以eval("console.log(\"test\")\n\n//# sourceURL=webpack:///./src/index.js?");这种方式包裹
l	每个module会封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL.


----------------------------cli命令说明----------------------
$ webpack --config webpack.config2.js 使用另一份配置文件（比如webpack.config2.js）来打包
$ webpack --watch, $ webpack -w//监听变动并自动打包
$ webpack -p//压缩混淆脚本，这个非常非常重要！
$ webpack -d//生成map映射文件，告知哪些模块被最终打包到哪里了其中的
$ webpack --progress //显示进度条
$ webpack --color,$ webpack -c //添加颜色
$ webpack --profile #输出性能数据，可以看到每一步的耗时
$ webpack --display-modules #默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块

  --context
  --entry
  --module-bind
  --module-bind-post
  --module-bind-pre
  --output-path
  --output-file
  --output-chunk-file
  --output-named-chunk-file
  --output-source-map-file
  --output-public-path
  --output-jsonp-function
  --output-pathinfo
  --output-library
  --output-library-target
  --records-input-path
  --records-output-path
  --records-path
  --define
  --target
  --cache                                                                                           [default: true]
  --watch-aggregate-timeout
  --watch-poll
  --hot
  --debug
  --devtool
  --progress
  --resolve-alias
  --resolve-loader-alias
  --optimize-max-chunks
  --optimize-min-chunk-size
  --optimize-minimize
  --optimize-occurence-order
  --optimize-dedupe
  --prefetch
  --provide
  --labeled-modules
  --plugin
  --bail
  --json, -j
  --sort-modules-by
  --sort-chunks-by
  --sort-assets-by
  --hide-modules
  --display-exclude
  --display-chunks
  --display-error-details
  --display-origins
  --display-cached
  --display-cached-assets
  --display-reasons, --verbose, -v

--------------------------------------

webpack插件
plugins
数组形式包住一个个 plugin 实例。
定义全局变量
webpack.DefinePlugin (官方的文档)
webpack.xxxxPlugin 这种插件是 webpack 的内置插件。
DefinePlugin：它的作用是定义全局常量，是常量。即在模块用它定义的全局常量，那么你就不能改变它的值啦。用法例子：
Plugins: [
    new webpack.DefinePlugin({
        '_ABC_': false
    })
]
自己定义一个需要定义apply
一、
ConsoleLogOnBuildWebpackPlugin.prototype.apply = function(compiler) {
  compiler.plugin('run', function(compiler, callback) {
    console.log("webpack 构建过程开始！！！");
    callback();
  });
};
二、hook
 let compiler = webpack(require('./webpack.config.js'));
  compiler.apply(new webpack.ProgressPlugin());
  compiler.run(function(err, stats) {
    // ...
  });
  
  内置plugins
  HotModuleReplacementPlugin --hot
  MinChunkSizePlugin --optimize-min-chunk-size
  LimitChunkCountPlugin --optimize-max-chunks
  webpackJsonp --output-jsonp-function
  UglifyJsPlugin --optimize-minimize
  LoaderOptionsPlugin --optimize-minimize

html-webpack-plugin
为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题
可以生成创建html入口文件，比如单页面可以生成一个html文件入口，配置N个html-webpack-plugin可以生成N个页面入口
var HtmlWebpackPlugin = require('html-webpack-plugin')

webpackconfig = {
    ...
    plugins: [
        new HtmlWebpackPlugin()
    ]
}
将 webpack中`entry`配置的相关入口thunk  和  `extract-text-webpack-plugin`抽取的css样式   插入到该插件提供的`template`或者`templateContent`配置项指定的内容基础上生成一个html文件，具体插入方式是将样式`link`插入到`head`元素中，`script`插入到`head`或者`body`中。

參數有
      template: path.join(__dirname, 'default_index.ejs'),
      templateParameters: templateParametersGenerator,
      filename: 'index.html',
      hash: false,
      inject: true,
      compile: true,
      favicon: false,
      minify: false,// { removeAttributeQuotes: true // 移除属性的引号 }注minify: true , 这样会报错
      cache: true,
      showErrors: true,
      chunks: 'all',
      excludeChunks: [],
      chunksSortMode: 'auto',
      meta: {},
      title: 'Webpack App',
      xhtml: false

template指定你生成的文件所依赖哪一个html文件模板，模板类型可以是html、jade、ejs等。但是要注意的是，如果想使用自定义的
title生成html文件的标题
filename就是生成html文件的文件名
inject有四个值： true body head false
	true 默认值，script标签位于html文件的 body 底部
	body script标签位于html文件的 body 底部
	head script标签位于html文件的 head中
	false 不插入生成的js文件，这个几乎不会用到的
favicon 给你生成的html文件生成一个 favicon ,值是一个路径
minify使用minify会对生成的html文件进行压缩
cache默认是true的，表示内容变化的时候生成一个新的文件。
showErrors当webpack报错的时候，会把错误信息包裹再一个pre中
chunks chunks主要用于多入口文件；chunks: ['index','main'】编译后：
	  <script type=text/javascript src="index.js"></script>
	  <script type=text/javascript src="main.js"></script>
excludeChunks excludeChunks: ['devor.js']排除掉一些js
xhtml一个布尔值，默认值是 false ，如果为 true ,则以兼容 xhtml 的模式引用文件
chunksSortMode script的顺序，默认四个选项： none auto dependency {function}
	'dependency' 不用说，按照不同文件的依赖关系来排序。
	'auto' 默认值，插件的内置的排序方式，具体顺序....
	'none' 无序？
	{function} 提供一个函数？

  extract-text-webpack-plugin
  ------------------------------------
  resolve
  解决require和import路径问题
   resolve：{
        alias: {
            'vue$': 'vue/dist/vue.js'
        }
    },
$表示结尾的意思，意思就是匹配vue
如果没有$表示可以匹配vue这个单词
-----------------------------------------
module
定义rules和loader

module:{rules:[
{
	test: /\.css$/,
	loader: "style!css!less",
	exclude: "/node_modules/",
	enforce: 'pre',
	include: [resolve('src')],
	options:{
		hotReload: false, // 热更新
		cssModules: {localIdentName: '[path][name]---[local]---[hash:base64:5]',camelCase: true},
		 limit: 10000,
		 name: 'static/img/[name].[hash:7].[ext]',
		 formatter: require('eslint-friendly-formatter'),
         emitWarning: !config.dev.showEslintErrorsInOverlay
	}
	query:{
    	name:'img/[name]-[hash:5].[ext]'  //不能和options同時用
    }
},
{ test: /\.css$/, loaders: ["style","css","less"] }
{ test: /\.html$/, loaders: "file-loader" },
{ test: /\.js$/, loaders: "babel-loader" },
{ test: /\.vue$/, loaders: "vue-loader"},
{ test: /\.js$/, loaders: "babel-loader" },
{ test: /\.css$/, loaders: [ 'vue-style-loader','css-loader']}
{ test: /\.s?css$/, loaders: [ MiniCssExtractPlugin.loader,'css-loader','sass-loader']}
{ test: /\.txt$/, loaders: 'raw-loader'}
{ test: /.(png|jpe?g|gif|svg)(\?.*)?$/, loaders: 'url-loader'}
{ test:  /\.(js|vue)$/, loaders: 'eslint-loader'}
{test: /\.html$/,use: 'file-loader?limit=1024&name=[path][name].[ext]&outputPath=img/&publicPath=output/'}
]}

url-loader：1.1.1 会将引入的文件以base64编码，根據參數limit值來生成dataURl；
只有文件超過limit值時，會調用file-loader，如果没有设置limit或者小於limit的文件全部转为base64方式
1个参数：limit、+6個file-loader的參數
两种方式字符串方式：
1、use: 'url-loader?limit=1024&name=[path][name].[ext]&outputPath=img/&publicPath=output/',
2、{ test: /\.(js|vue)$/, loader: 'eslint-loader', options: {}}

file-loader:2.0.0;可以通過query得到options;也可以定義opitons
6個參數：name、outputPath、publicPath、useRelativePath,context,emitFile。
context:指定根地址，默認是webpack.config.js的路徑
name可以是function也可以是string；通過loader-utils的interpolateName得到對應的規則[emoji] [hash] [ext] [name] [path] [folder];path是目錄帶/；folder表示文件夾（api/test/a.html這個路徑folder==test;path=="api/test/";name==a;ext==html）
outputPath可以是function也可以是string；得到outputPath + name
publicPath可以是function也可以是string；默認__webpack_public_path__ + outputPath；諾以"/"結尾就會得到publicPath+name方式;這值是針對Module export
useRelativePath：是flag；會得到和context的當前file的相對地址RelativePath最終改變 outputPath = outputPath + RelativePath + name
emitFile:false就導致loader不會生效

vue-loader是一个webpack的loader；可以将vue文件转换为JS模块；
vue-loader只处理.vue文件，你需要告诉webpack如何使用babel-loader或者buble-loader处理.js文件，在webpack中配置babel-loader或者buble-loader
vue-loader依赖css-loader、vue-template-compiler
所以要同时安装这两个
html-webpack-plugin插件来导出html文件。
这里打包css以sass 为例，用到了mini-css-extract-plugin插件提取css，用url-loader来处理字体、图片、音频等资源。非常简单
postcss-loader
通过eslint-loader 来配置eslint的检查，建立.eslintrc.js去设置规则
babel-load必须然后必须安装babel-loader babel-core
https://www.npmjs.com/package/babel-loader
如果index.js没有引用vue文件，打包的时候不会报错，如果引用了但是没有安装vue-loader就会提示Can't resolve 'vue-loader'
如果webpack里面没有配置vue-loader那么就会Module parse failed: Unexpected token
vue-html-loader  css-loader  vue-style-loader vue-hot-reload-api@1.3.2
css-loader、url-loader、html-loader
添加mini-css-extract-plugin，把css文件从bundle.js中独立成单独的css文件
file-loader是为了解决：希望在页面引入图片（包括img的src和background的url），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件
html-loader 这个包是为了解决html中img标签src引用的img这样通过解析html就可以调用img图片了
html-webpack-plugin
vue-html-loader





1、在js中import图片然后赋值给图片的src属性
import logo from '../img/logo.png';
document.getElementById('box').src = logo;
2、css中设置元素背景图片
.box{background-image: url(../img/logo.png)}
然后在js中通过import ‘@/css/index.css’的形式引入
3、在html的img标签中直接写入src属性，且一般是相对路径
<img src="img/logo.png" />
对于3中不能打包；可能是webpack已经升级了，需要用到html-withimg-loader'额外提供html的include子页面功能。


webapck4.0+以上版本不再推荐使用extract-text-webpack-plugin处理css模块，而使推荐mini-css-extract-plugin
實測we得到結論
1、webpack默認不能解析html、直接將html作爲入口會報錯；(You may need an appropriate loader to handle this file type.)
2、對於拷貝解析html的loader有；file-loader和html-webpack-plugin;
3、plugin和loader的區別；对于loader，它就是一个转换器；对于plugin，它就是一个扩展器，


--------------------------------------------
externals
表示不需要打包
---------------------------------------------
target
node表示运行环境为target
----------------------------------------------

事件
run：开始编译

make：从entry开始递归分析依赖并对依赖进行build
	--> build-moodule：使用loader加载文件并build模块
	--> normal-module-loader：对loader加载的文件用acorn编译，生成抽象语法树AST
	--> program：开始对AST进行遍历，当遇到require时触发call require事件
	--> seal：所有依赖build完成，开始对chunk进行优化（抽取公共模块、加hash等）
	--> optimize-chunk-assets：压缩代码

emit：把各个chunk输出到结果文件
