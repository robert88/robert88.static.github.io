以下个核心概念
entry
output
plugins
mode
optimization
devtool
resolve
module.rules.loader
target
externals
----------------------------
https://webpack.js.org/configuration/configuration-languages/
---------------------------
entry
来指定一个入口起点（或多个入口起点）。默认值为 "./src"
entry不配置的情况下，默认值是"./src"，webpack就会找到src目录下的index.js打包到output里面

--------------------------
devtool
https://www.cnblogs.com/wangyingblog/p/7027540.html
eval	每个module会封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL.
source-map	生成一个SourceMap文件.
hidden-source-map	和 source-map 一样，但不会在 bundle 末尾追加注释.
inline-source-map	生成一个 DataUrl 形式的 SourceMap 文件.
eval-source-map	每个module会通过eval()来执行，并且生成一个DataUrl形式的SourceMap.
cheap-source-map	生成一个没有列信息（column-mappings）的SourceMaps文件，不包含loader的 sourcemap（譬如 babel 的 sourcemap）
cheap-module-source-map	生成一个没有列信息（column-mappings）的SourceMaps文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。


webpack 不仅支持这 7 种，而且它们还是可以任意组合上面的eval、inline、hidden关键字，就如文档所说，你可以设置 souremap 选项为 cheap-module-inline-source-map。
cheap-module-eval-source-map
cheap-module-hidden-source-map
cheap-module-inline-source-map

----------------------------
mode
"development" //|| "production",
开发模式，不会混淆压缩打包，只是正常的合并
默认值为production
会混淆打包

-------------------------
默认即没有entry也没有output的情况下，webpack会进行下列操作
1、entry就会找到"./src/index.js",
mode:"production"并且混淆压缩的方式
打包到"./dist/main.js"

mode:"development" 来取消混淆打包，看看打包之后的文件是什么样的
原理利用表达式 !function(){console.log(arguments)}(1,2)的方式包裹函数
会模拟node调用的方式
****/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
最终返回return module.exports;
https://segmentfault.com/a/1190000010955254

devtool：默认是eval
会以eval("console.log(\"test\")\n\n//# sourceURL=webpack:///./src/index.js?");这种方式包裹
l	每个module会封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL.


----------------------------cli命令说明----------------------
$ webpack --config webpack.config2.js 使用另一份配置文件（比如webpack.config2.js）来打包
$ webpack --watch, $ webpack -w//监听变动并自动打包
$ webpack -p//压缩混淆脚本，这个非常非常重要！
$ webpack -d//生成map映射文件，告知哪些模块被最终打包到哪里了其中的
$ webpack --progress //显示进度条
$ webpack --color,$ webpack -c //添加颜色
$ webpack --profile #输出性能数据，可以看到每一步的耗时
$ webpack --display-modules #默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块

  --context
  --entry
  --module-bind
  --module-bind-post
  --module-bind-pre
  --output-path
  --output-file
  --output-chunk-file
  --output-named-chunk-file
  --output-source-map-file
  --output-public-path
  --output-jsonp-function
  --output-pathinfo
  --output-library
  --output-library-target
  --records-input-path
  --records-output-path
  --records-path
  --define
  --target
  --cache                                                                                           [default: true]
  --watch-aggregate-timeout
  --watch-poll
  --hot
  --debug
  --devtool
  --progress
  --resolve-alias
  --resolve-loader-alias
  --optimize-max-chunks
  --optimize-min-chunk-size
  --optimize-minimize
  --optimize-occurence-order
  --optimize-dedupe
  --prefetch
  --provide
  --labeled-modules
  --plugin
  --bail
  --json, -j
  --sort-modules-by
  --sort-chunks-by
  --sort-assets-by
  --hide-modules
  --display-exclude
  --display-chunks
  --display-error-details
  --display-origins
  --display-cached
  --display-cached-assets
  --display-reasons, --verbose, -v

--------------------------------------

webpack插件
plugins
数组形式包住一个个 plugin 实例。
定义全局变量
webpack.DefinePlugin (官方的文档)
webpack.xxxxPlugin 这种插件是 webpack 的内置插件。
DefinePlugin：它的作用是定义全局常量，是常量。即在模块用它定义的全局常量，那么你就不能改变它的值啦。用法例子：
Plugins: [
    new webpack.DefinePlugin({
        '_ABC_': false
    })
]
自己定义一个需要定义apply
一、
ConsoleLogOnBuildWebpackPlugin.prototype.apply = function(compiler) {
  compiler.plugin('run', function(compiler, callback) {
    console.log("webpack 构建过程开始！！！");
    callback();
  });
};
二、
 let compiler = webpack(require('./webpack.config.js'));
  compiler.apply(new webpack.ProgressPlugin());
  compiler.run(function(err, stats) {
    // ...
  });
  
  内置plugins
  HotModuleReplacementPlugin --hot
  MinChunkSizePlugin --optimize-min-chunk-size
  LimitChunkCountPlugin --optimize-max-chunks
  webpackJsonp --output-jsonp-function
  UglifyJsPlugin --optimize-minimize
  LoaderOptionsPlugin --optimize-minimize

webpack-html-plugin
html-webpack-plugin(目前是使用这个，但是上面的那个好像有点问题)
  ------------------------------------
  resolve
  解决require和import路径问题
   resolve：{
        alias: {
            'vue$': 'vue/dist/vue.js'
        }
    },
$表示结尾的意思，意思就是匹配vue
如果没有$表示可以匹配vue这个单词
-----------------------------------------
module
webpack4以上版本将use改为了loader
定义rules和loader

[
    { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" },
     {
          test: '\.vue$',
          loader: 'vue-loader',
          options: {
          hotReload: false // disables Hot Reload热更新
            cssModules: {
              localIdentName: '[path][name]---[local]---[hash:base64:5]',
              camelCase: true
            }
          }
        },
        { test: /\.txt$/, use: 'raw-loader' }
        ,
           {
            test: /\.js$/,
            loader: 'babel-loader',
            exclude: /node_modules/,
            include: resolve('src')
           },
                 {
                   test: /\.css$/,
                   use: [
                     'vue-style-loader',
                     'css-loader'
                   ]
                 }，
           {
                test: /\.s?css$/,
                use: [
                 MiniCssExtractPlugin.loader,
                 'css-loader',
                 'sass-loader'
                ]
               },
               {
                test: /.(png|jpe?g|gif|svg)(\?.*)?$/,
                loader: 'url-loader',
                options: {
                 limit: 10000,
                 name: 'static/img/[name].[hash:7].[ext]'
                }
               },
               {
                test: /\.(js|vue)$/,
                loader: 'eslint-loader',
                enforce: 'pre',
                include: [resolve('src')],
                exclude: /node_modules/,
                options: {
                 formatter: require('eslint-friendly-formatter'),
                 emitWarning: !config.dev.showEslintErrorsInOverlay
                }
               },
]
vue-loader是一个webpack的loader；可以将vue文件转换为JS模块；
vue-loader只处理.vue文件，你需要告诉webpack如何使用babel-loader或者buble-loader处理.js文件，在webpack中配置babel-loader或者buble-loader
vue-loader依赖css-loader、vue-template-compiler
所以要同时安装这两个
html-webpack-plugin插件来导出html文件。
这里打包css以sass 为例，用到了mini-css-extract-plugin插件提取css，用url-loader来处理字体、图片、音频等资源。非常简单
postcss-loader
通过eslint-loader 来配置eslint的检查，建立.eslintrc.js去设置规则
babel-load必须然后必须安装babel-loader babel-core
https://www.npmjs.com/package/babel-loader
如果index.js没有引用vue文件，打包的时候不会报错，如果引用了但是没有安装vue-loader就会提示Can't resolve 'vue-loader'
如果webpack里面没有配置vue-loader那么就会Module parse failed: Unexpected token
vue-html-loader  css-loader  vue-style-loader vue-hot-reload-api@1.3.2
css-loader、url-loader、html-loader
添加mini-css-extract-plugin，把css文件从bundle.js中独立成单独的css文件
file-loader是为了解决：希望在页面引入图片（包括img的src和background的url），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件
html-loader 这个包是为了解决html中img标签src引用的img这样通过解析html就可以调用img图片了
html-webpack-plugin
vue-html-loader

url-loader会将引入的图片编码，生成dataURl；url-loader封装了file-loader。url-loader不依赖于file-loader，（但不知具体原因是否是因为新版本url-loader将file-loader的功能剔除了。）
1.文件大小小于limit参数，url-loader将会把文件转为DataURL；
2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader
4个参数：limit、name、outputPath、publicPath。
两种方式字符串方式：1、use: 'url-loader?limit=1024&name=[path][name].[ext]&outputPath=img/&publicPath=output/',
2、{ test: /\.(js|vue)$/, loader: 'eslint-loader', options: {}}
如果没有设置limit将不会调用file-loader打包；全部转为base64方式

1、在js中import图片然后赋值给图片的src属性
import logo from '../img/logo.png';
document.getElementById('box').src = logo;
2、css中设置元素背景图片
.box{background-image: url(../img/logo.png)}
然后在js中通过import ‘@/css/index.css’的形式引入
3、在html的img标签中直接写入src属性，且一般是相对路径
<img src="img/logo.png" />
对于3中不能打包；可能是webpack已经升级了，需要用到html-withimg-loader'额外提供html的include子页面功能。


webapck4.0+以上版本不再推荐使用extract-text-webpack-plugin处理css模块，而使推荐mini-css-extract-plugin
--------------------------------------------
externals
表示不需要打包
---------------------------------------------
target
node表示运行环境为target
----------------------------------------------
