https://www.cnblogs.com/zhaoxiaoji/p/jasmine-node.html
https://www.jianshu.com/p/5254b4b1a5de
npm install -g jasmine

Jasmine有四个核心概念：分组(Suites)、用例(Specs)、期望(Expectations)、匹配(Matchers).

提供一个全局的函数
jasmine做为类库的全局变量使用（3.2.0提供10个属性，80个方法）
对外提供全局的变量接口调用
对应关系为如decribe调用jasmine.currentEnv_.decribe
如下是对应的接口为全局变量（15个全局变量,6大类）

 describe
 xdescribe
 fdescribe
 
 it
 xit
 fit
 
 expect
 expectAsync
 
 spyOn
 spyOnProperty

 beforeEach
 beforeAll
 afterEach
 afterAll
 
 pending
 fail
--------------------------------------------
提供25个mathers

nothing
toBe
toBeCloseTo
toBeDefined
toBeFalsy
toBeGreaterThan
toBeGreaterThanOrEqual
toBeLessThan
toBeLessThanOrEqual
toBeNaN
toBeNegativeInfinity
toBeNull
toBePositiveInfinity
toBeTruthy
toBeUndefined
toContain
toEqual
toHaveBeenCalled
toHaveBeenCalledBefore
toHaveBeenCalledTimes
toHaveBeenCalledWith
toHaveClass
toMatch
toThrow
toThrowError
toThrowMatching

3个matcherUtils
buildFailureMessage
contains
equals
---------------------------------------------
jasmine.util提供了12个方法
argsToArray //将arguments变为数组，方便调用数组的方法
arrayContains
clone
cloneArgs
errorWithStack
getPropertyDescriptor
has
htmlEscape
inherit
isUndefined
jasmineFile
objectDifference
--------------------------
jasmine提供了80个方法，这里来分类一下
提供类型判断方法有15个
isA_ //使用Object.prototype.toString是其他函数的基础函数；调用到getType_
isArray_
isAsyncFunction_
isDomNode
isError_
isFunction_  //调用isA_ 
isMap
isNumber_
isObject_
isPromise
isSet
isSpy
isString_
isTypedArray_
notEmpty

提供41个构造函数
Any
Anything
ArrayContaining
ArrayWithExactContents
AsyncExpectation
CallTracker
Clock
DelayedFunctionScheduler
DiffBuilder
Empty
Env
ExceptionFormatter
Expectation
Falsy
GlobalErrors 内部全局globalErrors是这个的实例
           //install
           //installOne_
           //originalHandlers
           //popListener
           //pushListener  将suite存储到全局的handler上面
           //uninstall

HtmlReporter 
          参数
       options.env
       options.getContainer,
       options.createElement,
       options.createTextNode,
       options.navigateWithNewParam 
       options.addToExistingQueryString 
       options.filterSpecs,
       options.timer 
          得到实例
            //displaySpecInCorrectFormat
            //initialize //通过options.getContainer获得根节点，并且将结构插入到根节点
                         <div class="jasmine_html-reporter">
                         <div class="jasmine-banner">
                         <a class="jasmine-title" href="http://jasmine.github.io/" target="_blank"></a>
                         <span class="jasmine-version">3.2.0</span>
                         </div>
                         <ul class="jasmine-symbol-summary"></ul>
                         <div class="jasmine-alert"></div>
                         <div class="jasmine-results">
                         <div class="jasmine-failures"></div>
                         </div>
                         </div>
            
            //jasmineDone
            //jasmineStarted
            //resultStatus
            //specDone
            //specStarted
            //suiteDone
            //suiteStarted

HtmlSpecFilter
JsApiReporter
MockDate
NotEmpty
ObjectContaining
ObjectPath
Order    //
    参数
       random: random,
       seed: seed
    得到一个实例
     random
     seed
     sort

QueryString
QueueRunner  //重要的执行函数
          
          参数
           options.clearStack
           options.completeOnFirstError
           options.deprecated
           options.fail
           options.globalErrors
           options.isReporter
           options.onComplete
           options.onException
           options.queueableFns
           options.timeout
           实例
           clearStack
           completeOnFirstError
           deprecated
           errored
           fail
           firstCleanupIx
           globalErrors
           handleFinalError
           onComplete
           onException
           queueableFns //reporter.jasmineStarted函数传递进来的函数
           timeout
           userContext //最终会以this方式传递到queueableFns
        -----proto
           attempt   //封装next函数，根据queueableFns中的函数的timeout来提示是否执行异步操作
           clearTimeout
           execute
           run
           setTimeout
           skipToCleanup



ReportDispatcher
ResultsNode
Spec
Spy
SpyFactory
SpyRegistry
SpyStrategy
StackTrace
StopExecutionError
StringMatching
Suite
Timer
TreeProcessor    //
        参数
               tree
              runnableIds
              queueRunnerFactory
              nodeStart
              nodeComplete
              orderChildren
              excludeNode
      实例
       execute
       processTree


Truthy
UserContext

提供25个实用工具
addCustomEqualityTester
addMatchers
addSpyStrategy
any
anything
arrayContaining
arrayWithExactContents
buildExpectationResult
clock
createSpy
createSpyObj
empty
falsy
fnNameFor
formatErrorMsg
getClearStack
getEnv
getGlobal
getType_  //使用Object.prototype.toString
objectContaining
pp
stringMatching
truthy
unimplementedMethod_

--------------------------------------------
调用方式
describe调用，这个函数返回一个Suite类

children是个Spec类
有四个数组存储callback
afterAllFns
afterFns
beforeAllFns
beforeFns //后进先出的规则得到callback

parentSuite；默认的parentSuite id是suite0
result结构集

env就是jasmine.currentEvn_

3个factory
asyncExpectationFactory
expectationFactory
expectationResultFactory //形参实这样的data = {matcherName: '',passed: false,expected: '', actual: '',error: arguments[0]};
                        messageFormatter得到一个j$.ExceptionFormatter()实例
                       data.messageFormatter = exceptionFormatter.message;
                       data.stackFormatter = exceptionFormatter.stack;
                       
                       返回一个result，其中message如果data.passed为true就是Passed.否则是data.message或者messageFormatter(data.error);
                       stack如果data.passed为true就是Passed.stackFormatter(data.error)或者data.errorForStack或者data.stack或者当前new errortrycatch

2个标识
description
id

原型里面扩展了一下方法
addChild //这个再addSpecsToSuite会调用，this.children调用push；因为是原型上的方法，这里this就指向了suite实例
addDeprecationWarning
addExpectationResult
afterAll
afterEach
beforeAll
beforeEach //this.beforeFns.unshift后进先出的规则

canBeReentered
cleanupBeforeAfter
clonedSharedUserContext
expect
expectAsync
getFullName
getResult
onException//这个会在函数里面有js错误的时候收集这些错误，并且绑定到suite上可以知道是哪一个suite报的错

             1、如果这个错误是 j$.errors.ExpectationFailed这个实例，就表示不收集
             这个错误是在suite这个addExpectationResult抛出也可以是spec的addExpectationResult抛出就会
             
             2、如果是正常的异常调用expectationResultFactory得到一个failedExpectation并且存储在suite.result.failedExpectations
          
pend
sharedUserContext
status

-------------------------------------
it调用，这个函数返回一个Spec类

3个factory
asyncExpectationFactory
expectationFactory
expectationResultFactory
queueRunnerFactory

beforeAndAfterFns
catchingExceptions
getSpecName  //先得到父类的fullname（即父类的description 树）如何将本身的description空格方式拼接到一起
queueableFn
userContext
onStart

result
resultCallback

result会将matcher整合passedExpectations
{matcherName: "toEqual", message: "Passed.", stack: "", passed: true}

原型里面扩展了一下方法
addDeprecationWarning
addExpectationResult
execute
expect
expectAsync
getFullName  //调用的是getSpecName
getResult
onException
pend
status

------------------------------------------
expect调用返回的是一个Expectation类
actual //用于存储实参
addExpectationResult
customEqualityTesters
isNot
not //这个也是一个Expectation
toBePlaying //这个是jasmine.addMatchers添加过来的
util这个和jasmine的matchersUtil是同一个
并且Expectation类的原型继承了jasmine.mathers,且在次基础上多扩展一个wrapCompare方法

---------------------------------调用流程-----------------------------------------------
describe调用流程

校验currentlyExecutingSuites是否为空，这个currentlyExecutingSuites是会在nodestart和jasmineStarted调用，即在这个时间里面不能调用descrbe

内部会使用j$==jasmine来表示

最终这个得到suiteFactory创建的一个suite，使用currentDeclarationSuite来存储这个suite0
然后通过addSpecsToSuite来执行function
currentDeclarationSuite变成了当前suite，这个下一个suite可以通过这变量获取到parentsuite
最终currentDeclarationSuite是会变回原来的值
specDefinitions会try catch错误会在  suite.onException被执行

最终定义的function被调用，并且将suite当做this调用实测function  specDefinitions.call(suite);
-------------------------------------------
beforeEach调用流程
在整个子页面调用过程currentDeclarationSuite指向的是decribe
  currentDeclarationSuite.beforeEach({
        fn: beforeEachFunction,
        timeout: timeout || 0
      });
      
-------------------------------------------------
it调用流程
通过specFactory得到spec实例j$.Spec(）
currentDeclarationSuite.addChild(spec)

-------------------------------------------------启动流程---------------------------------------------
html-standlone方式需要以下文件
jasmine.css,jasmine.js,jasmine.core.js,boot.js

在boot.js可以看到
    htmlReporter.initialize(); 创建html结构
    env.execute(); 创建jasmine.Order、和jasmine.TreeProcessor通过treeprocessor.processTree方法来创建一个process的树型结构
    启动reporter.jasmineStarted
    通过jasmine.ReportDispatcher来派送方法


