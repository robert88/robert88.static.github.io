Vue 最早会打包生成三个文件，一个是 runtime only 的文件 vue.common.js，一个是 compiler only 的文件 compiler.js，一个是 runtime + compiler 的文件 vue.js。

也就是说，vue.js = vue.common.js + compiler.js，而如果要使用 template 这个属性的话就一定要用 compiler.js，那么，引入 vue.js 是最恰当的。

如果[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.

表示只引用了runtime only

npm安装的vue package中的main指定的是  ，webpack会选用module
"main": "dist/vue.runtime.common.js",
"module": "dist/vue.runtime.esm.js",


new Vue

得到的是实例有：

$data
$isServer
$props
$ssrContext

$options
_isVue
_uid
_renderProxy
_self

$parent
$root
$children
$refs
_watcher
_inactive
_directInactive
_isMounted
_isDestroyed
_isBeingDestroyed

_hasHookEvent
_events

_vnode
_staticTrees
$slots
$scopedSlots
_c
$createElement

$attrs
$listeners
$emit

_data
_provided
_name
_isMounted

cid

-------------------------------------------------
看源码里vue的import路径会有映射的概念
需要看在用rollup打包的时候，有这么一个别名的配置
https://www.jianshu.com/p/983680723ec1
https://www.cnblogs.com/QH-Jimmy/p/6862539.html
-------------------------------------------------
vue options有以下这些
data、
parent、
el、
computed、
methods、
components
directives
filters
beforeCreate
created
beforeCompile
compiled
ready
beforeDestroy
destroyed
render
abstract
render._withStripped
staticRenderFns
_parentElm
_refElm
_isComponent
_base
_parentListeners
_parentVnode
_renderChildren
_parentListeners
_hasHookEvent

inject
props

provide
created
template
beforeMount
mounted
name
  --------------------------------------------------
 https://www.cnblogs.com/sichaoyun/p/8406194.html
 -----------------------------------------------
 component
 创建组件构造器、注册组件和使用组件
 注册组件Vue.component
 第一是directive自定义标签;,第二个是Vue.extend一个对象即VueComponet构造函数
 initAssetRegisters这个就是初始化components、directives、filters；可以看出这三个的逻辑是一样的
 参数id, definition
 
 如果definition不传递，表示获取组件id；Vue.components(id)==Vue.options.components[id]
 
 如果definition是对象
  definition.name = definition.name || id;
definition = this.options._base.extend(definition);

最后Vue.options.components存储这个实例，这样说来，就不用extend也是可以的
 -------------------------------------------------------------------------------
 Vue.extend
 Vue.options._base.extend ==  Vue.extend
 参数是个options
 template
 _Ctor内部定义的缓存
 name
得到实例
 继承了Vue.prototype
 super表示是vue
 cid
 options将当前的options和Vue的options合并，由于这个是在newVue之前，所以只会合并components、directives、filters、_base
 其中如果有name会存储.components[name]存储这个实例

 以下六个都是super的属性
extend;
mixin;
use;
components、
directives、
filters

superOptions对于super.options
extendOptions表示传递来的参数
sealedOptions表示super.opitons的拷贝
实例会被super.cid为key的方式存储

------------------------------------
如果需要使用.vue文件作为模块，就需要
vue-loader是一个webpack的loader；只将vue文件转换为JS模块； 包含三种类型的顶级语言快< template>< script>< style>

-----------------------------------------------
https://blog.csdn.net/xiaoheidaner2014/article/details/81506255
ES2015默认可用；
在每个 Vue 组件内支持其他的 Webpack 加载器，如用于<style>的 SASS 和用于<template> 的 Jade。
编译 ES2015、CoffeeScript 或 TypeScript 模块成 ES5 CommonJS 的模块；

编译之前，可以通过 linter 校验源代码。

编译 Jade 模板成 HTML 并内联 JavaScript 字符串。

编译 SASS 文件成 CSS，然后把生成的CSS插入到 <style> 标签内，然后再转译成 JavaScript 代码段。

处理在 HTML 或 CSS 文件中引用的图片文件，根据配置路径把它们移动到任意位置，根据 MD5 hash 命名。
vue-loader 默认用没有用语言编译器，想CSS 预编译和HTML模板编译语言等，如果想用这些功能，需要设置 lang 属性的来实现。
<style lang="sass">
  /* 编写 SASS! */
</style>
-------------------------------------
vue需要配置webpack插件或者babel插件
babel-plugin-transform-vue-jsx
这个组件和babel-plugin-transform-react-jsx不能同时使用
Usage
npm install\
  babel-plugin-syntax-jsx\
  babel-plugin-transform-vue-jsx\
  babel-helper-vue-jsx-merge-props\
  babel-preset-env\
  --save-dev
In your .babelrc:

{
  "presets": ["env"],
  "plugins": ["transform-vue-jsx"]
}
-----------------------------
报错
vue-loader was used without the corresponding plugin.

百度了一下，是因为vue-loader，15的版本需要再添加plugin的配置。有两种解决方法：
https://blog.csdn.net/weixin_38098195/article/details/80630958
官方是这样用的

const VueLoaderPlugin = require('vue-loader/lib/plugin')
module.exports = {
  module: {
    rules: [
      // ... other rules
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      }
    ]
  },
  plugins: [
    // make sure to include the plugin!
    new VueLoaderPlugin()
  ]
}
-----------------------
报错
[vue-loader] vue-template-compiler must be installed as a peer dependency
vue-loader内部必须依赖vue-template-compiler，而且需要手动安装

好像vue-loader内部默认可以处理es2015，所以可以不用安装babel来开发，除非要转义js文件
-----------------------------------
vue文件通过vue-loader转换为js对象
computed
data
methods{close: ƒ}
name
props
render
staticRenderFns
__file
_compiled
__proto__
---------------------------------------
所有的组件名称都是小写，如果有大写就会被转义为-连接
如ElAlert使用的时候就要<el-alert>
props定义变量可以使用
{
        type: String,
        default: '',
        required: true
      },
      来定义元素的类型和必填

      <el-alert title="test">
----------------------

